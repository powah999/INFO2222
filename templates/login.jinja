<!-- 
    Login page, user is redirected here when the user clicks on Login.
-->

{% extends 'base.jinja' %}

{% block content %}
<style>
    .container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        }

</style>

<ul class = "navbar">
    <li class="right"><a class="active" href="{{ url_for('logout')}}">Sign Out</a></li>
</ul>

<div class="container">
<h1>Hello World!</h1>
<h2>Login here:</h2>
<p>Username</p>
<input id="username" />
<p>Password</p>
<input id="password" type="password" />
<button onclick="login()">Login</button>

<br/><br/>
Need to make an account?
<a href={{ url_for('signup') }}>Click here to sign up!</a>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cryptico/0.0.1343522940/cryptico.min.js"></script>
<script>

    // basically checks if the server returns an Error message instead of a URL
    // this is a pretty terrible way of handling error generated by the server, but it works...
    function isValidURL(string) {
        if (string.length == 0) {
            return false;
        }
        if (string[0] == "/") {
            return true;
        }
        return false;
    }



    //input sanitization against xss
    function htmlEncode(str) {
        return String(str).replace(/[^\w. ]/gi, function (c) {
            return '&#' + c.charCodeAt(0) + ';';
        });
    }

    (function (c) {
        var parametersBigint = ["n", "d", "p", "q", "dmp1", "dmq1", "coeff"];

        c.privateKeyString = function (rsakey) {
            var keyObj = {};
            parametersBigint.forEach(function (parameter) {
                keyObj[parameter] = c.b16to64(rsakey[parameter].toString(16));
            });
            // e is 3 implicitly
            return JSON.stringify(keyObj);
        }
    })(cryptico)

    // login function to well login...
    async function login() {
        // this fancy syntax is part of the Jinja syntax
        // login_user is a Python function, this gets the URL that calls that Python function
        // you know the one with the:
        // app.route("/login/user", methods=["POST"])
        // login_user()
        // so... "{{ url_for('login_user')}}" 
        // gives us -> "http://blabla/login/user"

        var password = $("#password").val();
        var username = htmlEncode($("#username").val())
        let loginURL = "{{ url_for('login_user') }}";




        let res = await axios.post(loginURL, {
            username: username,
            requestType: 'salt'
        });

        if (res.data == 'User does not exist') {
            alert(res.data)
            return;
        }

        salt2 = res.data

        var hash = CryptoJS.SHA3((password + salt2), { outputLength: 256 }).toString(CryptoJS.enc.Hex);

        // axios post is a fancy way of posting a request to the server,
        // we pass in the username and password here
        let res1 = await axios.post(loginURL, {
            username: username,
            password: hash,
            requestType: 'password'
        });

        if (res1.data != 'pass') {
            alert(res1.data)
            return;
        }

        var saltObj = CryptoJS.enc.Hex.parse(salt2);

        //PBKDF2 key object
        var derivedKey = CryptoJS.PBKDF2(password, saltObj, {
            keySize: 256 / 32,
            iterations: 1000
        });

        //PBKDF2 key string format
        var stringDerived = derivedKey.toString(CryptoJS.enc.Base64);
        var privateKey = cryptico.generateRSAKey(stringDerived, 2048);
        var publicKey = cryptico.publicKeyString(privateKey);


        let res2 = await axios.post(loginURL, {
            username: username,
            password: hash,
            public: publicKey,
            requestType: 'key'

        });

        console.log("Public key: ", publicKey);

        // if the server sends in an error message, alert() the error message
        if (!isValidURL(res2.data)) {
            alert(res2.data);
            return;
        }

        //store derived and private key in local storage?
        localStorage.setItem("private", cryptico.privateKeyString(privateKey));
        localStorage.setItem("public", publicKey);

        window.open(res2.data, "_self")
    }
</script>
{% endblock %}